import pickle
from typing import Any, Dict, List, Tuple

import dimod
import pulp
from pulp.pulp import LpProblem


def analyze_constraints(
    prob: LpProblem, sample: Dict[str, int]
) -> Tuple[Dict[str, bool], int]:
    """check which constraints were satisfied

    :param prob: analyzed integer model
    :type prob: LpProblem
    :param sample: samples generated by the optimizer
    :type sample: Dict[str,int]
    :return: dictionary mapping constraint to whether they were satisfied, and
    the number of satisfied constraints
    :rtype: Dict[str,bool]
    """
    result = {}
    for cname, c in prob.constraints.items():
        sense = c.sense
        expr = sum(val * sample[var.name] for var, val in c.items())
        if sense == pulp.LpConstraintEQ:
            result[cname] = expr == -c.constant
        elif sense == pulp.LpConstraintLE:
            result[cname] = expr <= -c.constant
        elif sense == pulp.LpConstraintGE:
            result[cname] = expr >= -c.constant
    return result, sum(x == True for x in result.values())


def get_objective(prob: pulp.LpProblem, sample) -> float:
    """computes objective value for sample

    :param prob: the integer program with the relevant objective function
    :type prob: pulp.LpProblem
    :param sample: analyzed sample
    :type sample: [type]
    :return: value of the objective funtion
    :rtype: float
    """
    obj = prob.objective
    result = obj.constant
    result += sum(val * sample[var.name] for var, val in obj.items())
    return result


def get_best_feasible_sample(dict_list: List[Dict[str, Any]]) -> Dict[str, Any]:
    """output first feasible sample in the list

    :param dict_list: list of analyzed samples
    :type dict_list: List[Dict[str,Any]]
    :return: first feasible sample
    :rtype: Dict[str,Any]
    """
    best_feasible =  next((l for l in dict_list if l["feasible"]), None)
    if best_feasible:
        return best_feasible
    else:
        return sorted(dict_list, key=lambda d: d["energy"])[0]


def get_results(
    sampleset: dimod.SampleSet, prob: pulp.LpProblem
) -> List[Dict[str, Any]]:
    """Check samples one by one, and computes it statistics.

    Statistics includes energy (as provided by D'Wave), objective function
    value, feasibility analysis, the samples itself. Samples are sorted
    according to value of the objetive function

    :param sampleset: analyzed samples
    :type sampleset: dimod.SampleSet
    :param prob: integer problem according to which samples are analyzed
    :type prob: pulp.LpProblem
    :return: analyzed samples, sorted according to objective
    :rtype: List[Dict[str,Any]]
    """
    dict_list = []
    for data in sampleset.data():
        rdict = {}
        sample = data.sample
        rdict["energy"] = data.energy
        rdict["objective"] = round(get_objective(prob, sample), 2)
        rdict["feasible"] = all(analyze_constraints(prob, sample)[0].values())
        rdict["sample"] = sample
        rdict["feas_constraints"] = analyze_constraints(prob, sample)
        dict_list.append(rdict)
    return sorted(dict_list, key=lambda d: d["objective"])


def store_result(file_name: str, sampleset: dimod.SampleSet):
    """Save samples to the file

    :param file_name: name of the file
    :type file_name: str
    :param sampleset: samples
    :type sampleset: dimod.SampleSet
    """
    print(file_name)
    sdf = sampleset.to_serializable()
    with open(file_name, "wb") as handle:
        pickle.dump(sdf, handle)


def load_results(file_name: str) -> dimod.SampleSet:
    """Load samples from the file

    :param file_name: name of the file
    :type file_name: str
    :return: loaded samples
    :rtype: dimod.SampleSet
    """
    print(file_name)
    file = pickle.load(open(file_name, "rb"))
    return dimod.SampleSet.from_serializable(file)
